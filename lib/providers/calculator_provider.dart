import 'package:better_calculator/extensions/string_extension.dart';
import 'package:better_calculator/services/regex_utils.dart';
import 'package:flutter/material.dart';
import 'package:math_expressions/math_expressions.dart';

class CalculatorProvider extends ChangeNotifier {
  final Parser p = Parser();
  final ContextModel cm = ContextModel();

  String userInput = "";

  String get viewInput => _filterInput(userInput);

  double get calcResult => p.parse(userInput).evaluate(
        EvaluationType.REAL,
        cm,
      );

  String get inputLastChar => userInput.isNotEmpty
      ? userInput.substring(userInput.length - 1, userInput.length)
      : userInput;

  void addCharacterToCalc(String char) {
    userInput += char;
    userInput = _removeDuplicatedDots(userInput);
    userInput = _removeDuplicateOperators(userInput);

    notifyListeners();
  }

  void setResult() {}

  String _removeDuplicatedDots(String input) {
    // Split the input string by "."
    List<String> parts = input.split(".");

    // Join the parts together, omitting empty parts and preserving the first one
    String result = parts.first +
        (parts.length > 1
            ? ".${parts.skip(1).where((part) => part.isNotEmpty).join("")}"
            : "");

    return result;
  }

  void addRoundedBrackets() {
    // String openRoundedBracket = "(";
    // String closedRoundedBracket = ")";
    // late final String char;

    // bool isLastCharOpen = inputLastChar == openRoundedBracket;
    // int openOccur = userInput.countOccurrences(openRoundedBracket);
    // int closedOccur = userInput.countOccurrences(closedRoundedBracket);
    // bool isAllBracketsClosed = openOccur - closedOccur == 0;

    // if (isLastCharOpen || isAllBracketsClosed) {
    //   char = openRoundedBracket;
    // } else {
    //   char = closedRoundedBracket;
    // }

    // TODO: Allow moving across the expression with arrow keys.
    addCharacterToCalc("()");
  }

  void removeLastChar() {
    if (userInput.isNotEmpty) {
      userInput = userInput.substring(0, userInput.length - 1);
    }

    notifyListeners();
  }

  void clearInput() {
    userInput = "";
    notifyListeners();
  }

  String _addDotToNumbers(String input) {
    const String splitChar = ",";
    final List<String> splitNumericalsTypes = input.split(splitChar);

    String integers = splitNumericalsTypes[0];
    int totalIntegersToCalc = integers.length;

    while (totalIntegersToCalc > 3) {
      totalIntegersToCalc = totalIntegersToCalc - 3;
      integers = integers.insertCharAtPosition(".", totalIntegersToCalc);
    }

    bool isDecimalsIncluded = splitNumericalsTypes.length > 1;
    if (!isDecimalsIncluded) return integers;
    final String decimals = splitNumericalsTypes[1];
    return "$integers$splitChar$decimals";
  }

  String _replaceDecimalWithComma(String numberString) {
    int lastIndex = numberString.lastIndexOf('.');

    return lastIndex != -1
        ? numberString.replaceRange(lastIndex, lastIndex + 1, ",")
        : numberString;
  }

  // TODO: Most of filters down there are generated by AI and needs some refactoring
  // For readability and reliability

  String _filterInput(String input) {
    // Find all matches in the input string
    List<String> matches = RegexUtils.digitsRegExp
        .allMatches(input)
        .map((match) => match.group(0)!)
        .toList();

    // Iterate through the list
    for (int i = 0; i < matches.length; i++) {
      // Check if the current element is a number
      if (double.tryParse(matches[i]) != null) {
        // If it's a number, call the function to add a new value at the same position
        matches[i] = _replaceDecimalWithComma(matches[i]);
        matches[i] = _addDotToNumbers(matches[i]);
      }
    }

    return matches.join("");
  }

  String _removeDuplicateOperators(String input) {
    String result = "";
    String lastOperator = "";

    for (int i = 0; i < input.length; i++) {
      String currentChar = input[i];
      final bool isOperator = RegexUtils.operatorRegExp.hasMatch(currentChar);
      final bool isParenthesis = currentChar == "(" || currentChar == ")";

      // Check if the current character is an operator
      if (isOperator && !isParenthesis) {
        lastOperator = currentChar;
      } else {
        // If the current character is not an operator or a parenthesis, append the last operator (if any)
        if (lastOperator.isNotEmpty) {
          result += lastOperator;
          lastOperator = ""; // Reset the last operator
        }
        result += currentChar;
      }
    }

    // Append the last operator if any
    if (lastOperator.isNotEmpty) {
      result += lastOperator;
    }

    return result;
  }
}
